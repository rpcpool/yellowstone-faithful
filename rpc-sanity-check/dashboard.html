<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RPC Load Test Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #1a1a1a;
        color: #e0e0e0;
        margin: 0;
        padding: 20px;
      }
      .container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
        gap: 20px;
      }
      .card {
        background-color: #2d2d2d;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      }
      h2 {
        margin-top: 0;
        font-size: 1.2rem;
        color: #4caf50;
        border-bottom: 1px solid #444;
        padding-bottom: 10px;
      }
      canvas {
        width: 100% !important;
        height: 300px !important;
      }
      .stat-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        font-size: 0.9rem;
      }
      .stat-val {
        font-weight: bold;
        color: #fff;
      }
      #status {
        position: fixed;
        top: 10px;
        right: 20px;
        padding: 5px 10px;
        background: #333;
        border-radius: 4px;
        font-size: 0.8rem;
      }
      .flame-container {
        display: flex;
        flex-direction: column;
        height: 320px;
      }
    </style>
  </head>
  <body>
    <div id="status">Connecting...</div>
    <h1>RPC Load Test Metrics</h1>

    <div class="container">
      <!-- Latency Heatmap (Flame Buckets) -->
      <div class="card">
        <h2>RPC Response Latency (Buckets)</h2>
        <div class="flame-container">
          <canvas id="rpcLatencyChart"></canvas>
        </div>
      </div>

      <!-- CAR Lookup Latency (Flame Buckets) -->
      <div class="card">
        <h2>CAR Lookup Latency (Buckets)</h2>
        <div class="flame-container">
          <canvas id="carLatencyChart"></canvas>
        </div>
      </div>

      <!-- Throughput Line -->
      <div class="card">
        <h2>RPC Throughput (req/s) (Smoothed)</h2>
        <canvas id="throughputChart"></canvas>
      </div>

      <!-- Memory Line -->
      <div class="card">
        <h2>Memory Usage (Heap In-Use)</h2>
        <canvas id="memoryChart"></canvas>
      </div>

      <!-- Disk I/O Line -->
      <div class="card">
        <h2>Disk I/O Rate (Smoothed)</h2>
        <canvas id="diskIoChart"></canvas>
      </div>

      <!-- Errors -->
      <div class="card">
        <h2>RPC Errors</h2>
        <div class="stat-row">
          <span>Total Failures:</span>
          <span id="failCount" class="stat-val">0</span>
        </div>
        <canvas id="errorChart"></canvas>
      </div>

      <!-- Cache -->
      <div class="card">
        <h2>Cache Hit/Miss</h2>
        <canvas id="cacheChart"></canvas>
      </div>
    </div>

    <script>
      const API_URL = '/api/metrics';
      const MAX_HISTORY = 60; // Keep 60 seconds of history
      const SMOOTHING_ALPHA = 0.2; // Smoothing factor (0.0 - 1.0). Lower = smoother but more lag.

      // Utility to parse Prometheus Text Format
      function parsePrometheus(text) {
        const metrics = {};
        const lines = text.split('\n');

        lines.forEach((line) => {
          line = line.trim();
          if (!line || line.startsWith('#')) return;

          let match = line.match(
            /^([a-zA-Z0-9_]+)(?:\{([^}]+)\})?\s+([0-9eE\+\-\.]+)/,
          );
          if (match) {
            const key = match[1];
            const labelsStr = match[2];
            const value = parseFloat(match[3]);

            const labels = {};
            if (labelsStr) {
              labelsStr.split(',').forEach((l) => {
                const [k, v] = l.split('=');
                labels[k] = v.replace(/"/g, '');
              });
            }

            if (!metrics[key]) metrics[key] = [];
            metrics[key].push({ labels, value });
          }
        });
        return metrics;
      }

      // Utility to format bytes
      function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = [
          'B',
          'KiB',
          'MiB',
          'GiB',
          'TiB',
          'PiB',
          'EiB',
          'ZiB',
          'YiB',
        ];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return (
          parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]
        );
      }

      // Exponential Moving Average (EMA) helper
      function smooth(current, previous, alpha) {
        return alpha * current + (1 - alpha) * previous;
      }

      // Charts Initialization
      Chart.defaults.color = '#aaa';
      Chart.defaults.borderColor = '#444';

      const ctxRpcLat = document
        .getElementById('rpcLatencyChart')
        .getContext('2d');
      const ctxCarLat = document
        .getElementById('carLatencyChart')
        .getContext('2d');
      const ctxTps = document
        .getElementById('throughputChart')
        .getContext('2d');
      const ctxMem = document.getElementById('memoryChart').getContext('2d');
      const ctxErr = document.getElementById('errorChart').getContext('2d');
      const ctxCache = document.getElementById('cacheChart').getContext('2d');
      const ctxDisk = document.getElementById('diskIoChart').getContext('2d');

      const createBarChart = (ctx, label, color) =>
        new Chart(ctx, {
          type: 'bar',
          data: {
            labels: [],
            datasets: [{ label, data: [], backgroundColor: color }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: { x: { stacked: true }, y: { beginAtZero: true } },
            animation: false,
          },
        });

      const createLineChart = (ctx, label, color) =>
        new Chart(ctx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label,
                data: [],
                borderColor: color,
                tension: 0.1,
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: { y: { beginAtZero: true } },
            animation: false,
            elements: { point: { radius: 0 } },
          },
        });

      const chartRpcLat = createBarChart(ctxRpcLat, 'Count', '#ff5722');
      const chartCarLat = createBarChart(ctxCarLat, 'Count', '#2196f3');
      const chartTps = createLineChart(ctxTps, 'Req/s', '#4caf50');

      const chartMem = new Chart(ctxMem, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Bytes',
              data: [],
              borderColor: '#e91e63',
              tension: 0.1,
              fill: false,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function (value) {
                  return formatBytes(value);
                },
              },
            },
          },
          animation: false,
          elements: { point: { radius: 0 } },
          plugins: {
            tooltip: {
              callbacks: {
                label: function (context) {
                  return (
                    context.dataset.label + ': ' + formatBytes(context.parsed.y)
                  );
                },
              },
            },
          },
        },
      });

      const chartErr = createLineChart(ctxErr, 'Errors/s', '#f44336');

      const chartDisk = new Chart(ctxDisk, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Read',
              data: [],
              borderColor: '#03a9f4',
              tension: 0.1,
              fill: false,
            },
            {
              label: 'Write',
              data: [],
              borderColor: '#ff9800',
              tension: 0.1,
              fill: false,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function (value) {
                  return formatBytes(value) + '/s';
                },
              },
            },
          },
          animation: false,
          elements: { point: { radius: 0 } },
          plugins: {
            tooltip: {
              callbacks: {
                label: function (context) {
                  let label = context.dataset.label || '';
                  if (label) {
                    label += ': ';
                  }
                  if (context.parsed.y !== null) {
                    label += formatBytes(context.parsed.y) + '/s';
                  }
                  return label;
                },
              },
            },
          },
        },
      });

      const chartCache = new Chart(ctxCache, {
        type: 'doughnut',
        data: {
          labels: ['Hit', 'Miss'],
          datasets: [{ data: [0, 0], backgroundColor: ['#4caf50', '#f44336'] }],
        },
        options: { responsive: true, maintainAspectRatio: false },
      });

      // State for counters
      let previousTpsCount = 0;
      let previousErrCount = 0;
      let previousDiskRead = 0;
      let previousDiskWrite = 0;

      // State for smoothing (last displayed value)
      let smoothedTps = 0;
      let smoothedErr = 0;
      let smoothedDiskRead = 0;
      let smoothedDiskWrite = 0;

      let lastTime = Date.now();
      let firstRun = true;

      async function updateMetrics() {
        try {
          const response = await fetch(API_URL);
          if (!response.ok) throw new Error('Network response was not ok');
          const text = await response.text();
          const data = parsePrometheus(text);
          document.getElementById('status').innerText = 'Connected';
          document.getElementById('status').style.color = '#4caf50';

          const currentTime = Date.now();
          // Calculate precise time delta in seconds (protect against div by zero)
          let timeDelta = (currentTime - lastTime) / 1000;
          if (timeDelta <= 0) timeDelta = 1;
          const nowLabel = new Date().toLocaleTimeString();

          // 1. RPC Latency Histogram (Snapshot - no smoothing needed)
          if (data['rpc_response_latency_histogram_bucket']) {
            const buckets = data['rpc_response_latency_histogram_bucket']
              .filter(
                (b) =>
                  b.labels.rpc_method === 'getTransaction' &&
                  b.labels.le !== '+Inf',
              )
              .sort(
                (a, b) => parseFloat(a.labels.le) - parseFloat(b.labels.le),
              );

            const counts = [];
            const labels = [];
            let prev = 0;
            buckets.forEach((b) => {
              labels.push(b.labels.le + 's');
              counts.push(b.value - prev);
              prev = b.value;
            });

            chartRpcLat.data.labels = labels;
            chartRpcLat.data.datasets[0].data = counts;
            chartRpcLat.update();
          }

          // 2. CAR Lookup Latency (Snapshot - no smoothing needed)
          if (data['car_lookup_latency_histogram_bucket']) {
            const bucketMap = {};
            data['car_lookup_latency_histogram_bucket'].forEach((b) => {
              if (b.labels.le === '+Inf') return;
              if (!bucketMap[b.labels.le]) bucketMap[b.labels.le] = 0;
              bucketMap[b.labels.le] += b.value;
            });

            const keys = Object.keys(bucketMap).sort(
              (a, b) => parseFloat(a) - parseFloat(b),
            );
            const counts = [];
            const labels = [];
            let prev = 0;
            keys.forEach((k) => {
              labels.push(k + 's');
              const val = bucketMap[k];
              counts.push(val - prev);
              prev = val;
            });

            chartCarLat.data.labels = labels;
            chartCarLat.data.datasets[0].data = counts;
            chartCarLat.update();
          }

          // 3. Throughput (TPS) - Smoothed
          if (data['rpc_requests_by_method']) {
            const currentTotal =
              data['rpc_requests_by_method'].find(
                (m) => m.labels.method === 'getTransaction',
              )?.value || 0;
            if (!firstRun) {
              const rawDelta = currentTotal - previousTpsCount;
              const rawRate = rawDelta / timeDelta;
              // Avoid negative spikes on restarts
              const validRate = rawRate >= 0 ? rawRate : 0;

              smoothedTps = smooth(validRate, smoothedTps, SMOOTHING_ALPHA);
              updateLineChart(chartTps, nowLabel, smoothedTps);
            } else {
              // Init smoothed value to 0 or initial rate logic if preferred
              smoothedTps = 0;
            }
            previousTpsCount = currentTotal;
          }

          // 4. Memory (Gauge - no smoothing)
          if (data['go_memstats_heap_inuse_bytes']) {
            const mem = data['go_memstats_heap_inuse_bytes'][0].value;
            updateLineChart(chartMem, nowLabel, mem);
          }

          // 5. Disk I/O - Smoothed
          let currentRead = 0;
          let currentWrite = 0;
          if (data['disk_read_bytes_total']) {
            currentRead = data['disk_read_bytes_total'].reduce(
              (acc, curr) => acc + curr.value,
              0,
            );
          }
          if (data['disk_write_bytes_total']) {
            currentWrite = data['disk_write_bytes_total'].reduce(
              (acc, curr) => acc + curr.value,
              0,
            );
          }

          if (!firstRun) {
            const readRaw = (currentRead - previousDiskRead) / timeDelta;
            const writeRaw = (currentWrite - previousDiskWrite) / timeDelta;

            const validRead = readRaw >= 0 ? readRaw : 0;
            const validWrite = writeRaw >= 0 ? writeRaw : 0;

            smoothedDiskRead = smooth(
              validRead,
              smoothedDiskRead,
              SMOOTHING_ALPHA,
            );
            smoothedDiskWrite = smooth(
              validWrite,
              smoothedDiskWrite,
              SMOOTHING_ALPHA,
            );

            chartDisk.data.labels.push(nowLabel);
            chartDisk.data.datasets[0].data.push(smoothedDiskRead);
            chartDisk.data.datasets[1].data.push(smoothedDiskWrite);

            if (chartDisk.data.labels.length > MAX_HISTORY) {
              chartDisk.data.labels.shift();
              chartDisk.data.datasets[0].data.shift();
              chartDisk.data.datasets[1].data.shift();
            }
            chartDisk.update();
          }
          previousDiskRead = currentRead;
          previousDiskWrite = currentWrite;

          // 6. Errors - Smoothed
          let currentErrs = 0;
          if (data['method_to_success_or_failure']) {
            const failMetric = data['method_to_success_or_failure'].find(
              (m) => m.labels.status === 'failure',
            );
            if (failMetric) currentErrs = failMetric.value;
          }
          document.getElementById('failCount').innerText = currentErrs;
          if (!firstRun) {
            const rawErrDelta = currentErrs - previousErrCount;
            const rawErrRate = rawErrDelta / timeDelta;
            const validErrRate = rawErrRate >= 0 ? rawErrRate : 0;

            smoothedErr = smooth(validErrRate, smoothedErr, SMOOTHING_ALPHA);
            updateLineChart(chartErr, nowLabel, smoothedErr);
          }
          previousErrCount = currentErrs;

          // 7. Cache (Doughnut - Snapshot)
          if (data['cache_hit_miss_total']) {
            const hits =
              data['cache_hit_miss_total'].find(
                (m) => m.labels.result === 'hit',
              )?.value || 0;
            const misses =
              data['cache_hit_miss_total'].find(
                (m) => m.labels.result === 'miss',
              )?.value || 0;
            chartCache.data.datasets[0].data = [hits, misses];
            chartCache.update();
          }

          lastTime = currentTime;
          firstRun = false;
        } catch (e) {
          console.error(e);
          document.getElementById('status').innerText = 'Disconnected';
          document.getElementById('status').style.color = '#f44336';
        }
      }

      function updateLineChart(chart, label, data) {
        chart.data.labels.push(label);
        chart.data.datasets[0].data.push(data);
        if (chart.data.labels.length > MAX_HISTORY) {
          chart.data.labels.shift();
          chart.data.datasets[0].data.shift();
        }
        chart.update();
      }

      setInterval(updateMetrics, 1000);
      updateMetrics();
    </script>
  </body>
</html>
